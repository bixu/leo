#!/usr/bin/env node
// -*- mode: javascript -*-

var async = require('async');
var fs = require('fs');
var path = require('path');
var readline = require('readline');
var url = require('url');
var util = require('util');

libDir = path.resolve(__dirname, "..", "lib");
var Component = require(path.join(libDir, "Component.js"));
var Config = require(path.join(libDir, "Config.js"));

nadURL = "http://updates.circonus.net/node-agent/packages/";

var config = new Config();
config.readCommandLine();

if(config.help) {
    help();
    process.exit(-1);
}

var includedComponents = [];

async.series([
    config.readFromFile.bind(config),
    getNadPath,
    initialize,
    componentPrompts,
    main,
    finish
], function(err) {
    if(err) {
        process.exit(-1);
    }
});

/* -------------------------------------------------------------------------- */

// Components need the correct path to nad before they can initialize
function getNadPath(callback) {
    if(!config.nadpath) {
        config.nadpath = "/opt/circonus";
    }

    if(!fs.existsSync(config.nadpath) || !fs.existsSync(path.join(config.nadpath, "sbin", "nad"))) {
        promptUser({
            varname: "nadpath",
            text: util.format("Node.js Agent not found at %s.\n" +
                              "If nad is not installed, please visit %s and download the correct package for your platform.\n" +
                              "If nad is installed in another location, enter that location.",
                              config.nadpath, nadURL)
        }, function(err) {
            if(!fs.existsSync(config.nadpath) || !fs.existsSync(path.join(config.nadpath, "sbin", "nad"))) {
                return callback(util.format("nad not found at %s. Please visit %s and download the correct package for your platform.",
                                            config.nadpath, nadURL));
            }

            return callback(err);
        });
    }

    callback(null);
}

// Initialize: gather basic system information
function initialize(callback) {
    var tasks = [];

    // Read config file
    // Collect general system info from user
    tasks.push(function(callback) {
        getSystemInfo(function(err) {
            if(err) {
                console.error("Error collecting system configuration info:");
                console.error(err);
            }

            return callback(err);
        });
    });

    // Load and initialize components
    tasks.push(function(callback) {
        getAvailableComponents(function(err) {
            if(err) {
                console.error("Error finding components:");
                console.error(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Component prompts: for any components that need to prompt the user for more information
function componentPrompts(callback) {
    var tasks = [];

    // Run prompts for each component
    // These have to run in series since each one has to prompt the user
    tasks.push(function(callback) {
        runForEachComponent("prompts", {"series": true}, function(err) {
            if(err) {
                console.error("Error running components: %s", err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Main: create data structure
function main(callback) {
    var tasks = [];

    // Run main for each component
    tasks.push(function(callback) {
        runForEachComponent("main", {}, function(err) {
            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Finish: write config file, do API calls
function finish(callback) {
    var tasks = [];

    // Run cleanup for each component
    tasks.push(function(callback) {
        runForEachComponent("cleanup", {}, function(err) {
            if(err) {
                console.error("Error in component cleanup:");
                console.error(err);
            }

            return callback(err);
        });
    });

    // Add checks, graphs, and worksheets via API
    var api_tasks = [addChecks, addGraphs, addWorksheet];
    tasks.push(function(callback) {
        async.series(api_tasks, callback);
    });

    // Write config file
    tasks.push(function(callback) {
        config.writeToFile(function(err) {
            if(err) {
                console.error("Error writing config file:");
                console.error(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

/* -------------------------------------------------------------------------- */

function help(err) {
    console.info("usage: %s [options]", process.argv[1]);
    console.info();
    console.info("optional arguments:");
    console.info("\t%s\t this help message", "-h, --help");
    console.info("\t%s\t an IP or hostname for this server accessible by the Circonus broker", "-t, --target");
    console.info("\t%s\t your Circonus auth token", "-k, --authtoken");
    console.info("\t%s\t broker ID to use", "-b, --brokerid");
    console.info("\t%s\t location of config file", "-c, --configfile");
    console.info("\t%s\t skip prompts for metrics/graphs and use all default values", "--alldefault");
    console.info("\t%s\t location of nad installation (default: /opt/circonus)", "--nadpath");
    console.info();
}

function getSystemInfo(callback) {
    var tasks = [];

    tasks.push(function(callback) {
        promptUser({
            varname: "target",
            text: "Please enter a hostname or IP address that can be used by the Circonus broker to contact this host."
        }, function(err) {
            return callback(err);
        });
    });

    tasks.push(function(callback) {
        promptUser({
            varname: "authtoken",
            text: "Please enter your Circonus auth token."
        }, function(err) {
            config.api = require('circonusapi2');
            config.api.setup(config.authtoken, "nad");
            return callback(err);
        });
    });

    tasks.push(function(callback) {
        config.api.get("/broker", null, function(code, err, body) {
            if(err) {
                console.error("Couldn't get list of available brokers: %s", err);
                return callback(err);
            }
            config.availableBrokers = body;

            config.availableBrokers.forEach(function(broker) {
                var match = broker._cid.match( /\/broker\/(\d+)$/ );
                if(!match) {
                    return callback(util.format("Couldn't parse broker ID '%s'.", broker._cid));
                }

                broker.id = match[1];
            });

            config.availableBrokers.sort(function(a, b) {
                return a.id - b.id;
            });

            var promptText = "Select a broker to use:\n";
            config.availableBrokers.forEach(function(broker) {
                promptText += util.format("  %d. %s\n", broker.id, broker._name);
            });

            promptUser({
                varname: "brokerid",
                text: promptText
            }, function(err) {
                return callback(err);
            });
        });
    });

    // If a config file is specified and it existed, use its selections as "defaults",
    // and change prompt text to reflect that
    var promptText = "Would you like to use default selections for all checks and metrics?";
    if(config.configread) {
        promptText = "Would you like to use selections from the configuration file for all checks and metrics?";
    }

    tasks.push(function(callback) {
        promptUser({
            varname: "alldefault",
            text: promptText,
            defaultValue: "Y",
            modifyResponse: function(r) { return (r.toLowerCase().charAt(0) == "y"); },
        }, function(err) {
            return callback(err);
        });
    });

    async.series(tasks, function(err) {
        return callback(err);
    });
}

function promptUser(prompt, callback) {
    if(config[prompt.varname]) {
        return callback();
    }

    console.info(prompt.text);

    var rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    var promptText = "> ";
    if(prompt.defaultValue) {
        promptText = util.format("[%s] > ", prompt.defaultValue);
    }

    async.doUntil(function(callback) {
        rl.question(promptText, function(answer) {
            answer = answer || prompt.defaultValue;

            if(prompt.modifyResponse) {
                answer = prompt.modifyResponse(answer);
            }

            config[prompt.varname] = answer;
            return callback();
        });
    }, function() { return (!prompt.selections || prompt.selections.indexOf(config[prompt.varname]) > -1) }, function(err) {
        rl.close();
        return callback(err);
    });
}

function getAvailableComponents(callback) {
    var componentsDir = path.resolve(__dirname, '..', 'components');
    var tasks = [];

    fs.readdir(componentsDir, function(err, files) {
        if(err) {
            return callback(err);
        }

        files.forEach(function(filename) {
            fullPath = path.resolve(componentsDir, filename);

            if(path.extname(fullPath) == '.js') {
                component = new Component(fullPath);
                component.config = config;
                includedComponents.push(component);

                if(!component.initialize) {
                    return;
                }

                tasks.push(function(callback) {
                });
            }
        });

        runForEachComponent("initialize", {}, function(err) {
            if(err) {
                console.error("Error initializing components:");
                console.error(err);
            }

            return callback(err);
        });
    });
}

function runForEachComponent(functionName, opts, callback) {
    var tasks = [];

    includedComponents.forEach(function(component) {
        if(!component[functionName]) {
            return;
        }

        tasks.push(function(callback) {
            component[functionName](function(err) {
                if(err) {
                    console.error("Error running <%s.%s>: %s", component.name, functionName, err);
                }

                return callback(err);
            });
        });
    });

    if(opts.series) {
        async.series(tasks, function(err) {
            return callback(err);
        });
    } else {
        async.parallel(tasks, function(err) {
            return callback(err);
        });
    }
}

function addChecks(callback) {
    var checkBundleData = {
        "brokers": [ "/broker/" + config.brokerid ],
        "config": {
            "url": url.format({"protocol": "http", "hostname": config.target}),
            "port": 2609
        },
        "metrics": config.metrics,
        "period": 60,
        "status": "active",
        "target": config.target,
        "timeout": 10,
        "type": "json"
    };

    config.api.post("/check_bundle", checkBundleData, function(code, err, body) {
        config.checkID = body._checks[0].replace("/check/", "");
        return callback(err);
    });
}

function addGraphs(callback) {
    config.graphIDs = [];

    async.each(config.graphs, function(graph, callback) {
        var graphData = {
            "title": graph["title"],
            "datapoints": []
        };

        graph.datapoints.forEach(function(datapoint) {
            graphData.datapoints.push({
                "axis": "l",
                "check_id": config.checkID,
                "color": datapoint.color || "#4f4f9f",
                "data_formula": null,
                "derive": "gauge",
                "hidden": false,
                "legend_formula": null,
                "metric_name": datapoint.metric_name,
                "metric_type": "numeric",
                "name": datapoint.name || datapoint.metric_name,
                "stack": null
            });
        });

        config.api.post("/graph", graphData, function(code, err, body) {
            if(err) {
                console.error("Error adding graph: %s", err);
                return callback(err);
            }

            config.graphIDs.push(body._cid);
            return callback();
        });

    }, function(err, tasks) {
        return callback(err);
    });
}

function addWorksheet(callback) {
    var worksheetData = {
        "title": config.target,
        "graphs": config.graphIDs.map(function(id) { return {"graph": id}; })
    };

    config.api.post("/worksheet", worksheetData, function(code, err, body) {
        return callback(err);
    });
}
