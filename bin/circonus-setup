#!/usr/bin/env node
// -*- mode: javascript -*-

var async = require('async');
var fs = require('fs');
var path = require('path');
var readline = require('readline');
var minimist = require('minimist');
var jsonfile = require('jsonfile');

var argv = minimist(process.argv.slice(2), {
    alias: {
        "help": "h",
        "target": "t",
        "authtoken": ["k", "auth-token", "auth_token"],
        "brokerid": ["b", "broker-id", "broker_id"],
        "output": "o"
    }
});

if(argv.help) {
    help();
    process.exit(-1);
}

var configData = {
    graphs: {}
};

var components = [];

async.series([
    initialize,
    main,
    finish
], function(err) {
    if(err) {
        process.exit(-1);
    }
});

/* -------------------------------------------------------------------------- */

function initialize(callback) {
    var tasks = [];

    // Collect general system info from user
    var prompts = [
        { varname: "target", text: "Please enter a hostname or IP address that can be used by the Circonus broker to contact this host." },
        { varname: "authtoken", text: "Please enter your Circonus auth token." },
        { varname: "brokerid", text: "Please enter a broker ID to use." }
    ]

    tasks.push(function(callback) {
        getSystemInfo(argv, prompts, function(err) {
            if(err) {
                console.log("Error collecting system configuration info:");
                console.log(err);
            }

            return callback(err);
        });
    });

    // Load and initialize components
    tasks.push(function(callback) {
        getAvailableComponents(argv, components, function(err) {
            if(err) {
                console.log("Error finding components:");
                console.log(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

function main(callback) {
    // Run main for each component
    tasks.push(function(callback) {
        runComponents(argv, components, configData, function(err) {
            if(err) {
                console.log("Error running components:");
                console.log(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

function finish(callback) {
    // Run cleanup for each component
    tasks.push(function(callback) {
        cleanupComponents(argv, components, configData, function(err) {
            if(err) {
                console.log("Error in component cleanup:");
                console.log(err);
            }

            return callback(err);
        });
    });

    // Write config file
    tasks.push(function(callback) {
        writeConfigFile(argv, configData, function(err) {
            if(err) {
                console.log("Error writing config file:");
                console.log(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

/* -------------------------------------------------------------------------- */

function help(err) {
    console.log("usage: %s [options]", process.argv[1]);
    console.log();
    console.log("optional arguments:");
    console.log("\t%s\t this help message", "-h, --help");
    console.log("\t%s\t an IP or hostname for this server accessible by the Circonus broker", "-t, --target");
    console.log("\t%s\t your Circonus auth token", "-k, --authtoken");
    console.log("\t%s\t broker ID to use", "-b, --brokerid");
    console.log("\t%s\t location to write config file to", "-o, --output");
    console.log();
}

function getSystemInfo(info, prompts, callback) {
    tasks = []
    prompts.forEach(function(prompt) {
        tasks.push(function(callback) {
            if(info[prompt.varname]) {
                return callback();
            }

            console.log(prompt.text);

            var rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });

            var promptText = "> ";
            if(prompt.defaultValue) {
                promptText = util.format("[%s] > ", prompt.defaultValue);
            }

            rl.question(promptText, function(answer) {
                info[prompt.varname] = answer || prompt.defaultValue;
                rl.close();

                return callback();
            });
        });
    });

    async.series(tasks, function(err) {
        return callback(err);
    });
}

function getAvailableComponents(info, components, callback) {
    var componentsDir = path.resolve(__dirname, '..', 'components');
    tasks = [];

    fs.readdir(componentsDir, function(err, files) {
        if(err) {
            return callback(err);
        }

        files.forEach(function(filename) {
            fullPath = path.resolve(componentsDir, filename);

            if(path.extname(fullPath) == '.js') {
                component = {
                    name: path.basename(fullPath).replace('.js', ''),
                    module: require(fullPath)
                };

                components.push(component);

                if(!component.module.initialize) {
                    return;
                }

                tasks.push(function(callback) {
                    component.module.initialize(info, function(err) {
                        if(err) {
                            console.log("Error initializing component <%s>: %s", component.name, err);
                        }

                        return callback(err);
                    });
                });
            }
        });

        async.parallel(tasks, function(err) {
            return callback(err);
        });
    });
}

function runComponents(info, components, configData, callback) {
    tasks = [];

    components.forEach(function(component) {
        if(!component.module.main) {
            return;
        }

        console.log("running <%s>", component.name);

        tasks.push(function(callback) {
            component.module.main(info, configData, function(err) {
                if(err) {
                    console.log("Error running component <%s>: %s", component.name, err);
                }

                return callback(err);
            });
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

function cleanupComponents(info, components, configData, callback) {
    tasks = [];

    components.forEach(function(component) {
        if(!component.module.cleanup) {
            return;
        }

        console.log("running cleanup for <%s>", component.name);

        tasks.push(function(callback) {
            component.module.cleanup(info, configData, function(err) {
                if(err) {
                    console.log("Error running cleanup for component <%s>: %s", component.name, err);
                }

                return callback(err);
            });
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

function writeConfigFile(argv, configData, callback) {
    jsonfile.writeFile(argv.output, configData, function(err) {
        return callback(err);
    });
}