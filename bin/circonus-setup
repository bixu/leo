#!/usr/bin/env node
// -*- mode: javascript -*-

var async = require('async');
var fs = require('fs');
var jsonfile = require('jsonfile');
var minimist = require('minimist');
var path = require('path');
var readline = require('readline');
var url = require('url');
var util = require('util');

libDir = path.resolve(__dirname, "..", "lib");
var Component = require(path.join(libDir, "Component.js"));

nadURL = "http://updates.circonus.net/node-agent/packages/";

var userConfig = minimist(process.argv.slice(2), {
    alias: {
        "help": "h",
        "target": "t",
        "authtoken": ["k", "auth-token", "auth_token"],
        "brokerid": ["b", "broker-id", "broker_id"],
        "nadpath": ["nad-path", "nad_path"],
        "alldefault": ["all-default", "all_default", "alldefaults", "all-defaults", "all_defaults"],
        "output": "o"
    }
});

if(userConfig.help) {
    help();
    process.exit(-1);
}

var configData = {
    graphs: [],
    metrics: []
};

var includedComponents = [];

async.series([
    getNadPath,
    initialize,
    componentPrompts,
    main,
    finish
], function(err) {
    if(err) {
        process.exit(-1);
    }
});

/* -------------------------------------------------------------------------- */

// Components need the correct path to nad before they can initialize
function getNadPath(callback) {
    if(!userConfig.nadpath) {
        userConfig.nadpath = "/opt/circonus";
    }

    if(!fs.existsSync(userConfig.nadpath) || !fs.existsSync(path.join(userConfig.nadpath, "sbin", "nad"))) {
        promptUser({
            varname: "nadpath",
            text: util.format("Node.js Agent not found at %s.\n" +
                              "If nad is not installed, please visit %s and download the correct package for your platform.\n" +
                              "If nad is installed in another location, enter that location.",
                              userConfig.nadpath, nadURL)
        }, function(err) {
            if(!fs.existsSync(userConfig.nadpath) || !fs.existsSync(path.join(userConfig.nadpath, "sbin", "nad"))) {
                return callback(util.format("nad not found at %s. Please visit %s and download the correct package for your platform.",
                                            userConfig.nadpath, nadURL));
            }

            return callback(err);
        });
    }

    callback(null);
}

// Initialize: gather basic system information
function initialize(callback) {
    var tasks = [];

    // Collect general system info from user
    tasks.push(function(callback) {
        getSystemInfo(function(err) {
            if(err) {
                console.error("Error collecting system configuration info:");
                console.error(err);
            }

            return callback(err);
        });
    });

    // Load and initialize components
    tasks.push(function(callback) {
        getAvailableComponents(function(err) {
            if(err) {
                console.error("Error finding components:");
                console.error(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Component prompts: for any components that need to prompt the user for more information
function componentPrompts(callback) {
    var tasks = [];

    // Run prompts for each component
    // These have to run in series since each one has to prompt the user
    tasks.push(function(callback) {
        runForEachComponent("prompts", {"series": true}, function(err) {
            if(err) {
                console.error("Error running components: %s", err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Main: create data structure
function main(callback) {
    var tasks = [];

    // Run main for each component
    tasks.push(function(callback) {
        runForEachComponent("main", {}, function(err) {
            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Finish: write config file, run nad
function finish(callback) {
    var tasks = [];

    // Run cleanup for each component
    tasks.push(function(callback) {
        runForEachComponent("cleanup", {}, function(err) {
            if(err) {
                console.error("Error in component cleanup:");
                console.error(err);
            }

            return callback(err);
        });
    });

    // Add checks via API
    tasks.push(function(callback) {
        addChecks(function(err) {
            if(err) {
                console.error("Error adding checks via API:");
                console.error(err);
            }

            addGraphs(function(err) {
                if(err) {
                    console.error("Error adding graphs via API:");
                    console.error(err);
                }

                return callback(err);
            });
        });
    });

    // Write config file
    tasks.push(function(callback) {
        writeConfigFile(function(err) {
            if(err) {
                console.error("Error writing config file:");
                console.error(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

/* -------------------------------------------------------------------------- */

function help(err) {
    console.info("usage: %s [options]", process.argv[1]);
    console.info();
    console.info("optional arguments:");
    console.info("\t%s\t this help message", "-h, --help");
    console.info("\t%s\t an IP or hostname for this server accessible by the Circonus broker", "-t, --target");
    console.info("\t%s\t your Circonus auth token", "-k, --authtoken");
    console.info("\t%s\t broker ID to use", "-b, --brokerid");
    console.info("\t%s\t location to write config file to", "-o, --output");
    console.info();
}

function getSystemInfo(callback) {
    var tasks = [];

    tasks.push(function(callback) {
        promptUser({
            varname: "target",
            text: "Please enter a hostname or IP address that can be used by the Circonus broker to contact this host."
        }, function(err) {
            return callback(err);
        });
    });

    tasks.push(function(callback) {
        promptUser({
            varname: "authtoken",
            text: "Please enter your Circonus auth token."
        }, function(err) {
            userConfig.api = require('circonusapi2');
            userConfig.api.setup(userConfig.authtoken, "nad");
            return callback(err);
        });
    });

    tasks.push(function(callback) {
        userConfig.api.get("/broker", null, function(code, err, body) {
            if(err) {
                console.error("Couldn't get list of available brokers: %s", err);
                return callback(err);
            }
            userConfig.availableBrokers = body;

            userConfig.availableBrokers.forEach(function(broker) {
                var match = broker._cid.match( /\/broker\/(\d+)$/ );
                if(!match) {
                    return callback(util.format("Couldn't parse broker ID '%s'.", broker._cid));
                }

                broker.id = match[1];
            });

            userConfig.availableBrokers.sort(function(a, b) {
                return a.id - b.id;
            });

            var promptText = "Select a broker to use:\n";
            userConfig.availableBrokers.forEach(function(broker) {
                promptText += util.format("  %d. %s\n", broker.id, broker._name);
            });

            promptUser({
                varname: "brokerid",
                text: promptText
            }, function(err) {
                return callback(err);
            });
        });
    });

    tasks.push(function(callback) {
        promptUser({
            varname: "alldefault",
            text: "Would you like to use default selections for all checks and metrics?",
            defaultValue: "Y",
            modifyResponse: function(r) { return (r.toLowerCase().charAt(0) == "y"); },
        }, function(err) {
            return callback(err);
        });
    });

    async.series(tasks, function(err) {
        return callback(err);
    });
}

function promptUser(prompt, callback) {
    if(userConfig[prompt.varname]) {
        return callback();
    }

    console.info(prompt.text);

    var rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    var promptText = "> ";
    if(prompt.defaultValue) {
        promptText = util.format("[%s] > ", prompt.defaultValue);
    }

    async.doUntil(function(callback) {
        rl.question(promptText, function(answer) {
            answer = answer || prompt.defaultValue;

            if(prompt.modifyResponse) {
                answer = prompt.modifyResponse(answer);
            }

            userConfig[prompt.varname] = answer;
            return callback();
        });
    }, function() { return (!prompt.selections || prompt.selections.indexOf(userConfig[prompt.varname]) > -1) }, function(err) {
        rl.close();
        return callback(err);
    });
}

function getAvailableComponents(callback) {
    var componentsDir = path.resolve(__dirname, '..', 'components');
    var tasks = [];

    fs.readdir(componentsDir, function(err, files) {
        if(err) {
            return callback(err);
        }

        files.forEach(function(filename) {
            fullPath = path.resolve(componentsDir, filename);

            if(path.extname(fullPath) == '.js') {
                component = new Component(fullPath);
                component.userConfig = userConfig;
                component.configData = configData;
                includedComponents.push(component);

                if(!component.initialize) {
                    return;
                }

                tasks.push(function(callback) {
                });
            }
        });

        runForEachComponent("initialize", {}, function(err) {
            if(err) {
                console.error("Error initializing components:");
                console.error(err);
            }

            return callback(err);
        });
    });
}

function runForEachComponent(functionName, opts, callback) {
    var tasks = [];

    includedComponents.forEach(function(component) {
        if(!component[functionName]) {
            return;
        }

        tasks.push(function(callback) {
            component[functionName](function(err) {
                if(err) {
                    console.error("Error running <%s.%s>: %s", component.name, functionName, err);
                }

                return callback(err);
            });
        });
    });

    if(opts.series) {
        async.series(tasks, function(err) {
            return callback(err);
        });
    } else {
        async.parallel(tasks, function(err) {
            return callback(err);
        });
    }
}

function writeConfigFile(callback) {
    jsonfile.writeFile(userConfig.output, configData, function(err) {
        return callback(err);
    });
}

function addChecks(callback) {
    var checkBundleData = {
        "brokers": [ "/broker/" + userConfig.brokerid ],
        "config": {
            "url": url.format({"protocol": "http", "hostname": userConfig.target}),
            "port": 2609
        },
        "metrics": configData.metrics,
        "period": 60,
        "status": "active",
        "target": userConfig.target,
        "timeout": 10,
        "type": "json"
    };

    userConfig.api.post("/check_bundle", checkBundleData, function(code, err, body) {
        configData.checkID = body._checks[0].replace("/check/", "");
        return callback(err);
    });
}

function addGraphs(callback) {
    configData.graphIDs = [];

    async.each(configData.graphs, function(graph, callback) {
        var graphData = {
            "title": graph["title"],
            "datapoints": []
        };

        graph.datapoints.forEach(function(datapoint) {
            graphData.datapoints.push({
                "axis": "l",
                "check_id": configData.checkID,
                "color": datapoint.color || "#4f4f9f",
                "data_formula": null,
                "derive": "gauge",
                "hidden": false,
                "legend_formula": null,
                "metric_name": datapoint.metric_name,
                "metric_type": "numeric",
                "name": datapoint.name || datapoint.metric_name,
                "stack": null
            });
        });

        userConfig.api.post("/graph", graphData, function(code, err, body) {
            if(err) {
                console.error("Error adding graph: %s", err);
                return callback(err);
            }

            configData.graphIDs.push(body._cid);
            return callback();
        });

    }, function(err, tasks) {
        if(err) {
            return callback(err);
        }
    });
}