#!/usr/bin/env node
// -*- mode: javascript -*-

var async = require('async');
var fs = require('fs');
var path = require('path');
var readline = require('readline');
var minimist = require('minimist');
var jsonfile = require('jsonfile');

nadURL = "http://updates.circonus.net/node-agent/packages/";

var userConfig = minimist(process.argv.slice(2), {
    alias: {
        "help": "h",
        "target": "t",
        "authtoken": ["k", "auth-token", "auth_token"],
        "brokerid": ["b", "broker-id", "broker_id"],
        "nadpath": ["nad-path", "nad_path"],
        "output": "o"
    }
});

if(userConfig.help) {
    help();
    process.exit(-1);
}

var configData = {
    graphs: {},
    check: {
        type: "json",
        period: 60,
        timeout: 10,
        metrics: {
            numeric: [],
            text: []
        },
        config: {
            port: 2609
        }
    }
};

var includedComponents = [];

async.series([
    getNadPath,
    initialize,
    componentPrompts,
    main,
    finish
], function(err) {
    if(err) {
        process.exit(-1);
    }
});

/* -------------------------------------------------------------------------- */

// Components need the correct path to nad before they can initialize
function getNadPath(callback) {
    if(!userConfig.nadpath) {
        userConfig.nadpath = "/opt/circonus";
    }

    if(!fs.existsSync(userConfig.nadpath) || !fs.existsSync(path.join(userConfig.nadpath, "sbin", "nad"))) {
        promptUser({
            varname: "nadpath",
            text: util.format("Node.js Agent not found at %s.\n" +
                              "If nad is not installed, please visit %s and download the correct package for your platform.\n" +
                              "If nad is installed in another location, enter that location.",
                              userConfig.nadpath, nadURL)
        }, function(err) {
            if(!fs.existsSync(userConfig.nadpath) || !fs.existsSync(path.join(userConfig.nadpath, "sbin", "nad"))) {
                return callback(util.format("nad not found at %s. Please visit %s and download the correct package for your platform.",
                                            userConfig.nadpath, nadURL));
            }

            return callback(err);
        });
    }

    callback(null);
}

// Initialize: gather basic system information
function initialize(callback) {
    var tasks = [];

    // Collect general system info from user
    tasks.push(function(callback) {
        getSystemInfo(function(err) {
            if(err) {
                console.log("Error collecting system configuration info:");
                console.log(err);
            }

            return callback(err);
        });
    });

    // Load and initialize components
    tasks.push(function(callback) {
        getAvailableComponents(function(err) {
            if(err) {
                console.log("Error finding components:");
                console.log(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Component prompts: for any components that need to prompt the user for more information
function componentPrompts(callback) {
    // Run prompts for each component
    tasks.push(function(callback) {
        runForEachComponent("prompts", function(err) {
            if(err) {
                console.log("Error running components: %s", err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Main: create data structure
function main(callback) {
    // Run main for each component
    tasks.push(function(callback) {
        runForEachComponent("main", function(err) {
            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

// Finish: write config file, run nad
function finish(callback) {
    // Run cleanup for each component
    tasks.push(function(callback) {
        runForEachComponent("cleanup", function(err) {
            if(err) {
                console.log("Error in component cleanup:");
                console.log(err);
            }

            return callback(err);
        });
    });

    // Write config file
    tasks.push(function(callback) {
        writeConfigFile(function(err) {
            if(err) {
                console.log("Error writing config file:");
                console.log(err);
            }

            return callback(err);
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

/* -------------------------------------------------------------------------- */

function help(err) {
    console.log("usage: %s [options]", process.argv[1]);
    console.log();
    console.log("optional arguments:");
    console.log("\t%s\t this help message", "-h, --help");
    console.log("\t%s\t an IP or hostname for this server accessible by the Circonus broker", "-t, --target");
    console.log("\t%s\t your Circonus auth token", "-k, --authtoken");
    console.log("\t%s\t broker ID to use", "-b, --brokerid");
    console.log("\t%s\t location to write config file to", "-o, --output");
    console.log();
}

function getSystemInfo(callback) {
    var tasks = [];

    tasks.push(function(callback) {
        promptUser({
            varname: "target",
            text: "Please enter a hostname or IP address that can be used by the Circonus broker to contact this host."
        }, function(err) {
            return callback(err);
        });
    });

    tasks.push(function(callback) {
        promptUser({
            varname: "authtoken",
            text: "Please enter your Circonus auth token."
        }, function(err) {
            userConfig.api = require('circonusapi2');
            userConfig.api.setup(userConfig.authtoken, "nad");
            return callback(err);
        });
    });

    tasks.push(function(callback) {
        userConfig.api.get("/broker", null, function(code, err, body) {
            if(err) {
                console.log("Couldn't get list of available brokers: %s", err);
                return callback(err);
            }
            userConfig.availableBrokers = body;

            console.log("Select a broker to use:");
            userConfig.availableBrokers.forEach(function(broker) {
                var match = broker._cid.match( /\/broker\/(\d+)$/ );
                if(!match) {
                    return callback(util.format("Couldn't parse broker ID '%s'.", broker._cid));
                }

                broker.id = match[1];
            });

            userConfig.availableBrokers.sort(function(a, b) {
                return a.id - b.id;
            });

            userConfig.availableBrokers.forEach(function(broker) {
                console.log("  %d. %s", broker.id, broker._name);
            });

            promptUser({
                varname: "brokerid",
                text: ""
            }, function(err) {
                return callback(err);
            });
        });
    });

    async.series(tasks, function(err) {
        return callback(err);
    });
}

function promptUser(prompt, callback) {
    if(userConfig[prompt.varname]) {
        return callback();
    }

    console.log(prompt.text);

    var rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    var promptText = "> ";
    if(prompt.defaultValue) {
        promptText = util.format("[%s] > ", prompt.defaultValue);
    }

    rl.question(promptText, function(answer) {
        userConfig[prompt.varname] = answer || prompt.defaultValue;
        rl.close();

        return callback();
    });
}

function getAvailableComponents(callback) {
    var componentsDir = path.resolve(__dirname, '..', 'components');
    tasks = [];

    fs.readdir(componentsDir, function(err, files) {
        if(err) {
            return callback(err);
        }

        files.forEach(function(filename) {
            fullPath = path.resolve(componentsDir, filename);

            if(path.extname(fullPath) == '.js') {
                component = {
                    name: path.basename(fullPath).replace('.js', ''),
                    module: require(fullPath),
                    config: {}
                };

                includedComponents.push(component);

                if(!component.module.initialize) {
                    return;
                }

                tasks.push(function(callback) {
                    component.module.initialize(userConfig, component.config, function(err) {
                        if(err) {
                            console.log("Error initializing component <%s>: %s", component.name, err);
                        }

                        return callback(err);
                    });
                });
            }
        });

        async.parallel(tasks, function(err) {
            console.log(includedComponents);
            return callback(err);
        });
    });
}

function runForEachComponent(functionName, callback) {
    tasks = [];

    includedComponents.forEach(function(component) {
        if(!component.module.main) {
            return;
        }

        console.log("running <%s.%s>", component.name, functionName);

        tasks.push(function(callback) {
            component.module[functionName](userConfig, component.config, configData, function(err) {
                if(err) {
                    console.log("Error running <%s.%s>: %s", component.name, functionName, err);
                }

                return callback(err);
            });
        });
    });

    async.parallel(tasks, function(err) {
        return callback(err);
    });
}

function writeConfigFile(callback) {
    jsonfile.writeFile(userConfig.output, configData, function(err) {
        return callback(err);
    });
}

